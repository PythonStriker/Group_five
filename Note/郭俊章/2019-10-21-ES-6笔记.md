[TOC]
# ES-6
## let关键字
* 声明变量
* let声明的变量不能重复声明
* 不存在变量提升，临时性死区

## 块级作用域
* 代替闭包的一些功能
* 像for、if、else、while 等代码快 产生块级作用域
  
  ## const
  * 声明常量
  * 常量的值一旦声明就无法更改
  * sonst声明的常量同样存在作用域（局部、块级、全局）

## 全局作用域与顶层对象
* ES6中去掉了顶层对象的概念
* 为了向下兼容，在全局作用域中使用 var 声明的变量和直接声明的函数依然是顶层对象的属性和方法。
* 而使用 let 和 const 声明的变量不再输入顶层对象

## 解构赋值
* 保证等号两边的数值模式相同
* 如果两边不相同，则会有变量会自动赋值一个 underfined
* 变量可以有默认值
* 字符串可以当作字符组成的数组或变量
* 用于变量互相交换值
* 交换json中的数据
* 设置函数的默认值
* ES6模块

## for-of
```
let arr = ['red','green','blue'];
for(let val of arr){
console.log(val)
}
```
* for of 可以遍历那些类型的数据
* Arry数组	字符串		nodeList 	类数组对象
* arguments		Map		Set

## Iterator 	遍历器
* ES6定义的一个接口
* Array实现了Interator的接口
* 实现遍历器接口的数据类型都可以用于 for of

## 模板字符串
```
let html = 
`
<div>
		<div>
				<p>Hello</p>
				<a hrep="#">chao</a>
		</div>
</div>
`;
console.log(html);
```
* 模板字符串中插入变量  	${变量名}
* 模板字符串中插入函数的调用  	${函数名( )}

## 字符串方法
* repeat("2")		重复输出字符串两次
* padStart(10,"*")		用'*'把字符串从前面补全为 10个长度
* padEnd(10,"*")		用'*'把字符串从后面补全为 10个长度
* includes('a')		检查是否包含‘a’并返回一个 boor 值
* startsWith('hello')			检查是否是‘hello’开头
* endsWith('hello')			检查是否是‘hello’结尾

## 函数的新特性

## 扩展运算符 '...'
* 复制克隆数组（深拷贝）
* 合并数组
* 与解构赋值一起使用
```
let arr = [1,2,3,4,5,6,7]
let [a,b,...c] = arr;
//a = 1;
//b=2;
//c=[3,4,5,6,7]; 
```
* 作用于字符串
``` 
let arr = [...'hello'];
//arr = ['h,e,l,l,o'];
```

## 构造函数的新增方法
* 数组名.from()   可以把类数组对象转化为真正的数组
```
	//创建一个类数组对象
	let arrList = {
		0:'guo',
		1:'jun',
		2:'zhang',
		length:3
	}
```
* 数组名.of()		代替new Array(1,2,3)创建数组的方式

## 数组对象新增的方法
* find（）返回数组中第一个满足条件的元素，参数时回调函数。
```
//获取数组中大于7的第一个元素值
	let arr = [0,1,3,4,6,8,9,0];
	console.log(arr.find(function(val){
		return val > 7
	}))
	//推荐使用箭头函数的方法写回调函数
	console.log(arr.find(val=>val>7))
```
* findIndex（）返回数组中第一个满足条件的元素的索引，参数是回调函数。
```
	//获取数组中第一个奇数的元素索引
	let arr = [0,1,3,4,6,8,9,0];
	console.log(arr.findIndex(function(val){
		return (val % 2) !== 0
	}))
	//推荐使用箭头函数的方法写回调函数
	console.log(arr.findIndex(val=>(val%2)!==0))
```
* 遍历数组的两种方法	.keys( )	.entries( )
```
	let arr = [0,1,3,4,6,8,9,0];
	//遍历数组获取数组的key
	for (let key of arr.keys()){
		console.log(key);
	}
	//遍历数组获取数组的key，value
	for (let [key,val] of arr.entries()){
		console.log(key,val);
	}
```

## set 类数组的数据结构
* 类似于数组但是成员唯一，定义数组时自动去重。
* set结构只有值没有索引
* .size 	返回set长度
* .add(value)			  添加成员
* .delete(value)		删除成员
* .has(Value)		 	  判断，返回一个boor值
* .clear(  ) 					清空所有成员

## map类对象的数据结构
* map跟对象类似，键值对组成集合，键的类型可以时任意类型
* 函数的参数可以时数组，数组是二维数组，元素数组两个元素，key  value
* .size		获取 map 中的键值对数目
* .get（key）	获取键值对应的value
* .set（key，value）修改，添加键值对

## promise
* 回调函数的参数是上一个回调函数的返回值，且异步执行
* 为了代码的易读性 需要一个方式来让异步执行可以向顺序执行一样
```
let p = new Promise(function(resolve,reject){
	console.log('ok');
	resolve('数据');
});
p.then(function(data){
	console.log(data);
})
```
* .then(构造函数) 上一级函数成功执行 获取上一级返回的resolve
* .catch(构造函数)	上一级函数失败执行时	获取上一级返回的reject
* promise.all(一个数组，数组中是多个promaise对象)，只有全部回调函数都完成执行时才会输出。
```
//有三个promise对象分别为：fun1，fun2，fun3
Promise.all([fun1( ),fun2( ),fun3( )])
				.then(res=>{
					console.log(res);
				})
				.catch(msg=>{
				console.log(msg);
				})
```
* promise.race(一个数组，数组中是多个promaise对象)，那个对象先完成就先输出那个对象的结果。

## 模块
* 在模块中定义输出	export
* 在主js中引用	import
* 推荐使用把模块中所有的想要引用的元素放在一个对象中，然后使用“export default 对象名”来定义模块的输出，